{"version":3,"file":"index.js","names":["operatorOptions: TOperatorOptionForDisplay[]","uuidv4","tempExpression: E | undefined"],"sources":["../src/store/rich-filters/adapter.ts","../src/store/rich-filters/config.ts","../src/store/rich-filters/config-manager.ts","../src/store/rich-filters/filter-helpers.ts","../src/store/rich-filters/filter.ts","../src/store/work-item-filters/adapter.ts","../src/utils/rich-filter.helper.ts","../src/utils/work-item-filters.helper.ts","../src/store/work-item-filters/filter.store.ts"],"sourcesContent":["// plane imports\nimport type { IFilterAdapter, TExternalFilter, TFilterExpression, TFilterProperty } from \"@plane/types\";\n\n/**\n * Abstract base class for converting between external filter formats and internal filter expressions.\n * Provides common utilities for creating and manipulating filter nodes.\n *\n * @template K - Property key type that extends TFilterProperty\n * @template E - External filter type that extends TExternalFilter\n */\nexport abstract class FilterAdapter<K extends TFilterProperty, E extends TExternalFilter> implements IFilterAdapter<\n  K,\n  E\n> {\n  /**\n   * Converts an external filter format to internal filter expression.\n   * Must be implemented by concrete adapter classes.\n   *\n   * @param externalFilter - The external filter to convert\n   * @returns The internal filter expression or null if conversion fails\n   */\n  abstract toInternal(externalFilter: E): TFilterExpression<K> | null;\n\n  /**\n   * Converts an internal filter expression to external filter format.\n   * Must be implemented by concrete adapter classes.\n   *\n   * @param internalFilter - The internal filter expression to convert\n   * @returns The external filter format\n   */\n  abstract toExternal(internalFilter: TFilterExpression<K> | null): E;\n}\n","import { set } from \"lodash-es\";\nimport { action, computed, makeObservable, observable, runInAction } from \"mobx\";\nimport { computedFn } from \"mobx-utils\";\n// plane imports\nimport { EMPTY_OPERATOR_LABEL } from \"@plane/constants\";\nimport type {\n  TSupportedOperators,\n  TFilterConfig,\n  TFilterProperty,\n  TFilterValue,\n  TOperatorSpecificConfigs,\n  TAllAvailableOperatorsForDisplay,\n} from \"@plane/types\";\nimport { FILTER_FIELD_TYPE } from \"@plane/types\";\nimport {\n  getOperatorLabel,\n  isDateFilterType,\n  getDateOperatorLabel,\n  isDateFilterOperator,\n  getOperatorForPayload,\n} from \"@plane/utils\";\n\ntype TOperatorOptionForDisplay = {\n  value: TAllAvailableOperatorsForDisplay;\n  label: string;\n};\n\nexport interface IFilterConfig<P extends TFilterProperty, V extends TFilterValue = TFilterValue> extends TFilterConfig<\n  P,\n  V\n> {\n  // computed\n  allEnabledSupportedOperators: TSupportedOperators[];\n  firstOperator: TSupportedOperators | undefined;\n  // computed functions\n  getOperatorConfig: (\n    operator: TAllAvailableOperatorsForDisplay\n  ) => TOperatorSpecificConfigs<V>[keyof TOperatorSpecificConfigs<V>] | undefined;\n  getLabelForOperator: (operator: TAllAvailableOperatorsForDisplay | undefined) => string;\n  getDisplayOperatorByValue: <T extends TSupportedOperators>(operator: T, value: V) => T;\n  getAllDisplayOperatorOptionsByValue: (value: V) => TOperatorOptionForDisplay[];\n  // actions\n  mutate: (updates: Partial<TFilterConfig<P, V>>) => void;\n}\n\nexport class FilterConfig<P extends TFilterProperty, V extends TFilterValue = TFilterValue> implements IFilterConfig<\n  P,\n  V\n> {\n  // observables\n  id: IFilterConfig<P, V>[\"id\"];\n  label: IFilterConfig<P, V>[\"label\"];\n  icon?: IFilterConfig<P, V>[\"icon\"];\n  isEnabled: IFilterConfig<P, V>[\"isEnabled\"];\n  supportedOperatorConfigsMap: IFilterConfig<P, V>[\"supportedOperatorConfigsMap\"];\n  allowMultipleFilters: IFilterConfig<P, V>[\"allowMultipleFilters\"];\n\n  /**\n   * Creates a new FilterConfig instance.\n   * @param params - The parameters for the filter config.\n   */\n  constructor(params: TFilterConfig<P, V>) {\n    this.id = params.id;\n    this.label = params.label;\n    this.icon = params.icon;\n    this.isEnabled = params.isEnabled;\n    this.supportedOperatorConfigsMap = params.supportedOperatorConfigsMap;\n    this.allowMultipleFilters = params.allowMultipleFilters;\n\n    makeObservable(this, {\n      id: observable,\n      label: observable,\n      icon: observable,\n      isEnabled: observable,\n      supportedOperatorConfigsMap: observable,\n      allowMultipleFilters: observable,\n      // computed\n      allEnabledSupportedOperators: computed,\n      firstOperator: computed,\n      // actions\n      mutate: action,\n    });\n  }\n\n  // ------------ computed ------------\n\n  /**\n   * Returns all supported operators.\n   * @returns All supported operators.\n   */\n  get allEnabledSupportedOperators(): IFilterConfig<P, V>[\"allEnabledSupportedOperators\"] {\n    return Array.from(this.supportedOperatorConfigsMap.entries())\n      .filter(([, operatorConfig]) => operatorConfig.isOperatorEnabled)\n      .map(([operator]) => operator);\n  }\n\n  /**\n   * Returns the first operator.\n   * @returns The first operator.\n   */\n  get firstOperator(): IFilterConfig<P, V>[\"firstOperator\"] {\n    return this.allEnabledSupportedOperators[0];\n  }\n\n  // ------------ computed functions ------------\n\n  /**\n   * Returns the operator config.\n   * @param operator - The operator.\n   * @returns The operator config.\n   */\n  getOperatorConfig: IFilterConfig<P, V>[\"getOperatorConfig\"] = computedFn((operator) =>\n    this.supportedOperatorConfigsMap.get(getOperatorForPayload(operator).operator)\n  );\n\n  /**\n   * Returns the label for an operator.\n   * @param operator - The operator.\n   * @returns The label for the operator.\n   */\n  getLabelForOperator: IFilterConfig<P, V>[\"getLabelForOperator\"] = computedFn((operator) => {\n    if (!operator) return EMPTY_OPERATOR_LABEL;\n\n    const operatorConfig = this.getOperatorConfig(operator);\n\n    if (operatorConfig?.operatorLabel) {\n      return operatorConfig.operatorLabel;\n    }\n\n    if (operatorConfig?.type && isDateFilterType(operatorConfig.type) && isDateFilterOperator(operator)) {\n      return getDateOperatorLabel(operator);\n    }\n\n    return getOperatorLabel(operator);\n  });\n\n  /**\n   * Returns the operator for a value.\n   * @param value - The value.\n   * @returns The operator for the value.\n   */\n  getDisplayOperatorByValue: IFilterConfig<P, V>[\"getDisplayOperatorByValue\"] = computedFn((operator, value) => {\n    const operatorConfig = this.getOperatorConfig(operator);\n    if (operatorConfig?.type === FILTER_FIELD_TYPE.MULTI_SELECT && (Array.isArray(value) ? value.length : 0) <= 1) {\n      return operatorConfig.singleValueOperator as typeof operator;\n    }\n    return operator;\n  });\n\n  /**\n   * Returns all supported operator options for display in the filter UI.\n   * This method filters out operators that are already applied (unless multiple filters are allowed)\n   * and includes both positive and negative variants when supported.\n   *\n   * @param value - The current filter value used to determine the appropriate operator variant\n   * @returns Array of operator options with their display labels and values\n   */\n  getAllDisplayOperatorOptionsByValue: IFilterConfig<P, V>[\"getAllDisplayOperatorOptionsByValue\"] = computedFn(\n    (value) => {\n      const operatorOptions: TOperatorOptionForDisplay[] = [];\n\n      // Process each supported operator to build display options\n      for (const operator of this.allEnabledSupportedOperators) {\n        const displayOperator = this.getDisplayOperatorByValue(operator, value);\n        const displayOperatorLabel = this.getLabelForOperator(displayOperator);\n        operatorOptions.push({\n          value: operator,\n          label: displayOperatorLabel,\n        });\n\n        const additionalOperatorOption = this._getAdditionalOperatorOptions(operator, value);\n        if (additionalOperatorOption) {\n          operatorOptions.push(additionalOperatorOption);\n        }\n      }\n\n      return operatorOptions;\n    }\n  );\n\n  // ------------ actions ------------\n\n  /**\n   * Mutates the config.\n   * @param updates - The updates to apply to the config.\n   */\n  mutate: IFilterConfig<P, V>[\"mutate\"] = action((updates) => {\n    runInAction(() => {\n      for (const key in updates) {\n        if (updates.hasOwnProperty(key)) {\n          const configKey = key as keyof TFilterConfig<P, V>;\n          set(this, configKey, updates[configKey]);\n        }\n      }\n    });\n  });\n\n  // ------------ private helpers ------------\n\n  private _getAdditionalOperatorOptions = (\n    _operator: TSupportedOperators,\n    _value: V\n  ): TOperatorOptionForDisplay | undefined => undefined;\n}\n","import { action, computed, makeObservable, observable } from \"mobx\";\nimport { computedFn } from \"mobx-utils\";\n// plane imports\nimport type { TConfigOptions } from \"@plane/constants\";\nimport { DEFAULT_FILTER_CONFIG_OPTIONS } from \"@plane/constants\";\nimport type { TExternalFilter, TFilterConfig, TFilterProperty, TFilterValue } from \"@plane/types\";\n// local imports\nimport type { IFilterConfig } from \"./config\";\nimport { FilterConfig } from \"./config\";\nimport type { IFilterInstance } from \"./filter\";\n\n/**\n * Interface for managing filter configurations.\n * Provides methods to register, update, and retrieve filter configurations.\n * - filterConfigs: Map storing filter configurations by their ID\n * - configOptions: Configuration options controlling filter behavior\n * - allConfigs: All registered filter configurations\n * - allAvailableConfigs: All available filter configurations based on current state\n * - getConfigByProperty: Retrieves a filter configuration by its ID\n * - register: Registers a single filter configuration\n * - registerAll: Registers multiple filter configurations\n * - updateConfigByProperty: Updates an existing filter configuration by ID\n * @template P - The filter property type extending TFilterProperty\n */\nexport interface IFilterConfigManager<P extends TFilterProperty> {\n  // observables\n  filterConfigs: Map<P, IFilterConfig<P, TFilterValue>>; // filter property -> config\n  configOptions: TConfigOptions;\n  areConfigsReady: boolean;\n  // computed\n  allAvailableConfigs: IFilterConfig<P, TFilterValue>[];\n  // computed functions\n  getConfigByProperty: (property: P) => IFilterConfig<P, TFilterValue> | undefined;\n  // helpers\n  register: <C extends TFilterConfig<P, TFilterValue>>(config: C) => void;\n  registerAll: (configs: TFilterConfig<P, TFilterValue>[]) => void;\n  updateConfigByProperty: (property: P, configUpdates: Partial<TFilterConfig<P, TFilterValue>>) => void;\n  setAreConfigsReady: (value: boolean) => void;\n}\n\n/**\n * Parameters for initializing the FilterConfigManager.\n * - options: Optional configuration options to override defaults\n */\nexport type TConfigManagerParams = {\n  options?: Partial<TConfigOptions>;\n};\n\n/**\n * Manages filter configurations for a filter instance.\n * Handles registration, updates, and retrieval of filter configurations.\n * Provides computed properties for available configurations based on current filter state.\n *\n * @template P - The filter property type extending TFilterProperty\n * @template V - The filter value type extending TFilterValue\n * @template E - The external filter type extending TExternalFilter\n */\nexport class FilterConfigManager<\n  P extends TFilterProperty,\n  E extends TExternalFilter = TExternalFilter,\n> implements IFilterConfigManager<P> {\n  // observables\n  filterConfigs: IFilterConfigManager<P>[\"filterConfigs\"];\n  configOptions: IFilterConfigManager<P>[\"configOptions\"];\n  areConfigsReady: IFilterConfigManager<P>[\"areConfigsReady\"];\n  // parent filter instance\n  private _filterInstance: IFilterInstance<P, E>;\n\n  /**\n   * Creates a new FilterConfigManager instance.\n   *\n   * @param filterInstance - The parent filter instance this manager belongs to\n   * @param params - Configuration parameters for the manager\n   */\n  constructor(filterInstance: IFilterInstance<P, E>, params: TConfigManagerParams) {\n    this.filterConfigs = new Map<P, IFilterConfig<P>>();\n    this.configOptions = this._initializeConfigOptions(params.options);\n    this.areConfigsReady = true;\n    // parent filter instance\n    this._filterInstance = filterInstance;\n\n    makeObservable(this, {\n      filterConfigs: observable,\n      configOptions: observable,\n      areConfigsReady: observable,\n      // computed\n      allAvailableConfigs: computed,\n      // helpers\n      register: action,\n      registerAll: action,\n      updateConfigByProperty: action,\n      setAreConfigsReady: action,\n    });\n  }\n\n  // ------------ computed ------------\n\n  /**\n   * Returns all available filterConfigs.\n   * If allowSameFilters is true, all enabled configs are returned.\n   * Otherwise, only configs that are not already applied to the filter instance are returned.\n   * @returns All available filterConfigs.\n   */\n  get allAvailableConfigs(): IFilterConfigManager<P>[\"allAvailableConfigs\"] {\n    const appliedProperties = new Set(this._filterInstance.allConditions.map((condition) => condition.property));\n    // Return all enabled configs that either allow multiple filters or are not currently applied\n    return this._allEnabledConfigs.filter((config) => config.allowMultipleFilters || !appliedProperties.has(config.id));\n  }\n\n  // ------------ computed functions ------------\n\n  /**\n   * Returns a config by filter property.\n   * @param property - The property to get the config for.\n   * @returns The config for the property, or undefined if not found.\n   */\n  getConfigByProperty: IFilterConfigManager<P>[\"getConfigByProperty\"] = computedFn(\n    (property) => this.filterConfigs.get(property) as IFilterConfig<P, TFilterValue>\n  );\n\n  // ------------ helpers ------------\n\n  /**\n   * Register a config.\n   * If a config with the same property already exists, it will be updated with the new values.\n   * Otherwise, a new config will be created.\n   * @param configUpdates - The config updates to register.\n   */\n  register: IFilterConfigManager<P>[\"register\"] = action((configUpdates) => {\n    if (this.filterConfigs.has(configUpdates.id)) {\n      // Update existing config if it has differences\n      const existingConfig = this.filterConfigs.get(configUpdates.id)!;\n      existingConfig.mutate(configUpdates);\n    } else {\n      // Create new config if it doesn't exist\n      this.filterConfigs.set(configUpdates.id, new FilterConfig(configUpdates));\n    }\n  });\n\n  /**\n   * Register all configs.\n   * @param configs - The configs to register.\n   */\n  registerAll: IFilterConfigManager<P>[\"registerAll\"] = action((configs) => {\n    configs.forEach((config) => this.register(config));\n  });\n\n  /**\n   * Updates a config by filter property.\n   * @param property - The property of the config to update.\n   * @param configUpdates - The updates to apply to the config.\n   */\n  updateConfigByProperty: IFilterConfigManager<P>[\"updateConfigByProperty\"] = action((property, configUpdates) => {\n    const prevConfig = this.filterConfigs.get(property);\n    prevConfig?.mutate(configUpdates);\n  });\n\n  /**\n   * Updates the configs ready state.\n   * @param value - The new configs ready state.\n   */\n  setAreConfigsReady: IFilterConfigManager<P>[\"setAreConfigsReady\"] = action((value) => {\n    this.areConfigsReady = value;\n  });\n\n  // ------------ private computed ------------\n\n  private get _allConfigs(): IFilterConfig<P, TFilterValue>[] {\n    return Array.from(this.filterConfigs.values());\n  }\n\n  /**\n   * Returns all enabled filterConfigs.\n   * @returns All enabled filterConfigs.\n   */\n  private get _allEnabledConfigs(): IFilterConfig<P, TFilterValue>[] {\n    return this._allConfigs.filter((config) => config.isEnabled);\n  }\n\n  // ------------ private helpers ------------\n\n  /**\n   * Initializes the config options.\n   * @param options - The options to initialize the config options with.\n   * @returns The initialized config options.\n   */\n  private _initializeConfigOptions(options?: Partial<TConfigOptions>): TConfigOptions {\n    return DEFAULT_FILTER_CONFIG_OPTIONS ? { ...DEFAULT_FILTER_CONFIG_OPTIONS, ...options } : options || {};\n  }\n}\n","import { cloneDeep } from \"lodash-es\";\nimport { action, makeObservable, observable, toJS } from \"mobx\";\n// plane imports\nimport type { TAutoVisibilityOptions, TExpressionOptions } from \"@plane/constants\";\nimport { DEFAULT_FILTER_EXPRESSION_OPTIONS } from \"@plane/constants\";\nimport type {\n  IFilterAdapter,\n  TSupportedOperators,\n  TFilterConditionNode,\n  TFilterExpression,\n  TFilterValue,\n  TFilterProperty,\n  TExternalFilter,\n  TLogicalOperator,\n  TFilterConditionPayload,\n} from \"@plane/types\";\nimport { LOGICAL_OPERATOR } from \"@plane/types\";\nimport { addAndCondition, createConditionNode, updateNodeInExpression } from \"@plane/utils\";\n// local imports\nimport type { IFilterInstance } from \"./filter\";\n\ntype TFilterInstanceHelperParams<P extends TFilterProperty, E extends TExternalFilter> = {\n  adapter: IFilterAdapter<P, E>;\n};\n\n/**\n * Interface for filter instance helper utilities.\n * Provides comprehensive methods for filter expression manipulation, node operations,\n * operator utilities, and expression restructuring.\n * @template P - The filter property type extending TFilterProperty\n * @template E - The external filter type extending TExternalFilter\n */\nexport interface IFilterInstanceHelper<P extends TFilterProperty, E extends TExternalFilter> {\n  isVisible: boolean;\n  // initialization\n  initializeExpression: (initialExpression?: E) => TFilterExpression<P> | null;\n  initializeExpressionOptions: (expressionOptions?: Partial<TExpressionOptions<E>>) => TExpressionOptions<E>;\n  // visibility\n  setInitialVisibility: (visibilityOption: TAutoVisibilityOptions) => void;\n  toggleVisibility: (isVisible?: boolean) => void;\n  // condition operations\n  addConditionToExpression: <V extends TFilterValue>(\n    expression: TFilterExpression<P> | null,\n    groupOperator: TLogicalOperator,\n    condition: TFilterConditionPayload<P, V>,\n    isNegation: boolean\n  ) => TFilterExpression<P> | null;\n  handleConditionPropertyUpdate: (\n    expression: TFilterExpression<P>,\n    conditionId: string,\n    property: P,\n    operator: TSupportedOperators,\n    isNegation: boolean\n  ) => TFilterExpression<P> | null;\n  // group operations\n  restructureExpressionForOperatorChange: (\n    expression: TFilterExpression<P>,\n    conditionId: string,\n    newOperator: TSupportedOperators,\n    isNegation: boolean,\n    shouldResetValue: boolean\n  ) => TFilterExpression<P> | null;\n}\n\n/**\n * Comprehensive helper class for filter instance operations.\n * Provides utilities for filter expression manipulation, node operations,\n * operator transformations, and expression restructuring.\n *\n * @template K - The filter property type extending TFilterProperty\n * @template E - The external filter type extending TExternalFilter\n */\nexport class FilterInstanceHelper<\n  P extends TFilterProperty,\n  E extends TExternalFilter,\n> implements IFilterInstanceHelper<P, E> {\n  // parent filter instance\n  private _filterInstance: IFilterInstance<P, E>;\n  // adapter\n  private adapter: IFilterAdapter<P, E>;\n  // visibility\n  isVisible: boolean;\n\n  /**\n   * Creates a new FilterInstanceHelper instance.\n   *\n   * @param adapter - The filter adapter for converting between internal and external formats\n   */\n  constructor(filterInstance: IFilterInstance<P, E>, params: TFilterInstanceHelperParams<P, E>) {\n    this._filterInstance = filterInstance;\n    this.adapter = params.adapter;\n    this.isVisible = false;\n\n    makeObservable(this, {\n      isVisible: observable,\n      setInitialVisibility: action,\n      toggleVisibility: action,\n    });\n  }\n\n  // ------------ initialization ------------\n\n  /**\n   * Initializes the filter expression from external format.\n   * @param initialExpression - The initial expression to initialize the filter with\n   * @returns The initialized filter expression or null if no initial expression provided\n   */\n  initializeExpression: IFilterInstanceHelper<P, E>[\"initializeExpression\"] = (initialExpression) => {\n    if (!initialExpression) return null;\n    return this.adapter.toInternal(toJS(cloneDeep(initialExpression)));\n  };\n\n  /**\n   * Initializes the filter expression options with defaults.\n   * @param expressionOptions - Optional expression options to override defaults\n   * @returns The initialized filter expression options\n   */\n  initializeExpressionOptions: IFilterInstanceHelper<P, E>[\"initializeExpressionOptions\"] = (expressionOptions) => ({\n    ...DEFAULT_FILTER_EXPRESSION_OPTIONS,\n    ...expressionOptions,\n  });\n\n  /**\n   * Sets the initial visibility state for the filter based on options and active filters.\n   * @param visibilityOption - The visibility options for the filter instance.\n   * @returns The initial visibility state\n   */\n  setInitialVisibility: IFilterInstanceHelper<P, E>[\"setInitialVisibility\"] = action((visibilityOption) => {\n    // If explicit initial visibility is provided, use it\n    if (visibilityOption.autoSetVisibility === false) {\n      this.isVisible = visibilityOption.isVisibleOnMount;\n      return;\n    }\n\n    // If filter has active filters, make it visible\n    if (this._filterInstance.hasActiveFilters) {\n      this.isVisible = true;\n      return;\n    }\n\n    // Default to hidden if no active filters\n    this.isVisible = false;\n    return;\n  });\n\n  /**\n   * Toggles the visibility of the filter.\n   * @param isVisible - The visibility to set.\n   */\n  toggleVisibility: IFilterInstanceHelper<P, E>[\"toggleVisibility\"] = action((isVisible) => {\n    if (isVisible !== undefined) {\n      this.isVisible = isVisible;\n      return;\n    }\n    this.isVisible = !this.isVisible;\n  });\n\n  // ------------ condition operations ------------\n\n  /**\n   * Adds a condition to the filter expression based on the logical operator.\n   * @param expression - The current filter expression\n   * @param groupOperator - The logical operator to use for the condition\n   * @param condition - The condition to add\n   * @param isNegation - Whether the condition should be negated\n   * @returns The updated filter expression\n   */\n  addConditionToExpression: IFilterInstanceHelper<P, E>[\"addConditionToExpression\"] = (\n    expression,\n    groupOperator,\n    condition,\n    isNegation\n  ) => this._addConditionByOperator(expression, groupOperator, this._getConditionPayloadToAdd(condition, isNegation));\n\n  /**\n   * Updates the property and operator of a condition in the filter expression.\n   * This method updates the property, operator, resets the value, and handles negation properly.\n   * @param expression - The filter expression to operate on\n   * @param conditionId - The ID of the condition being updated\n   * @param property - The new property for the condition\n   * @param operator - The new operator for the condition\n   * @param isNegation - Whether the condition should be negated\n   * @returns The updated expression\n   */\n  handleConditionPropertyUpdate: IFilterInstanceHelper<P, E>[\"handleConditionPropertyUpdate\"] = (\n    expression,\n    conditionId,\n    property,\n    operator,\n    isNegation\n  ) => {\n    const payload = { property, operator, value: undefined };\n\n    return this._updateCondition(expression, conditionId, payload, isNegation);\n  };\n\n  // ------------ group operations ------------\n\n  /**\n   * Restructures the expression when a condition's operator changes between positive and negative.\n   * @param expression - The filter expression to operate on\n   * @param conditionId - The ID of the condition being updated\n   * @param newOperator - The new operator for the condition\n   * @param isNegation - Whether the operator is negation\n   * @param shouldResetValue - Whether to reset the condition value\n   * @returns The restructured expression\n   */\n  restructureExpressionForOperatorChange: IFilterInstanceHelper<P, E>[\"restructureExpressionForOperatorChange\"] = (\n    expression,\n    conditionId,\n    newOperator,\n    isNegation,\n    shouldResetValue\n  ) => {\n    const payload = shouldResetValue ? { operator: newOperator, value: undefined } : { operator: newOperator };\n\n    return this._updateCondition(expression, conditionId, payload, isNegation);\n  };\n\n  // ------------ private helpers ------------\n\n  /**\n   * Gets the condition payload to add to the expression.\n   * @param conditionNode - The condition node to add\n   * @param isNegation - Whether the condition should be negated\n   * @returns The condition payload to add\n   */\n  private _getConditionPayloadToAdd = (\n    condition: TFilterConditionPayload<P, TFilterValue>,\n    _isNegation: boolean\n  ): TFilterExpression<P> => {\n    const conditionNode = createConditionNode(condition);\n\n    return conditionNode;\n  };\n\n  /**\n   * Handles the logical operator switch for adding conditions.\n   * @param expression - The current expression\n   * @param groupOperator - The logical operator\n   * @param conditionToAdd - The condition to add\n   * @returns The updated expression\n   */\n  private _addConditionByOperator(\n    expression: TFilterExpression<P> | null,\n    groupOperator: TLogicalOperator,\n    conditionToAdd: TFilterExpression<P>\n  ): TFilterExpression<P> | null {\n    switch (groupOperator) {\n      case LOGICAL_OPERATOR.AND:\n        return addAndCondition(expression, conditionToAdd);\n      default:\n        console.warn(`Unsupported logical operator: ${groupOperator}`);\n        return expression;\n    }\n  }\n\n  /**\n   * Updates a condition with the given payload and handles negation wrapping/unwrapping.\n   * @param expression - The filter expression to operate on\n   * @param conditionId - The ID of the condition being updated\n   * @param payload - The payload to update the condition with\n   * @param isNegation - Whether the condition should be negated\n   * @returns The updated expression with proper negation handling\n   */\n  private _updateCondition = (\n    expression: TFilterExpression<P>,\n    conditionId: string,\n    payload: Partial<TFilterConditionNode<P, TFilterValue>>,\n    _isNegation: boolean\n  ): TFilterExpression<P> | null => {\n    // Update the condition with the payload\n    updateNodeInExpression(expression, conditionId, payload);\n\n    return expression;\n  };\n}\n","import { cloneDeep, isEqual } from \"lodash-es\";\nimport { action, computed, makeObservable, observable, toJS } from \"mobx\";\nimport { computedFn } from \"mobx-utils\";\nimport { v4 as uuidv4 } from \"uuid\";\n// plane imports\nimport type {\n  TClearFilterOptions,\n  TExpressionOptions,\n  TFilterOptions,\n  TSaveViewOptions,\n  TUpdateViewOptions,\n} from \"@plane/constants\";\nimport { DEFAULT_FILTER_VISIBILITY_OPTIONS } from \"@plane/constants\";\nimport type {\n  IFilterAdapter,\n  SingleOrArray,\n  TAllAvailableOperatorsForDisplay,\n  TExternalFilter,\n  TFilterConditionNode,\n  TFilterConditionNodeForDisplay,\n  TFilterConditionPayload,\n  TFilterExpression,\n  TFilterProperty,\n  TFilterValue,\n  TLogicalOperator,\n  TSupportedOperators,\n} from \"@plane/types\";\nimport { FILTER_NODE_TYPE } from \"@plane/types\";\n// local imports\nimport {\n  deepCompareFilterExpressions,\n  extractConditions,\n  extractConditionsWithDisplayOperators,\n  findConditionsByPropertyAndOperator,\n  findNodeById,\n  hasValidValue,\n  removeNodeFromExpression,\n  sanitizeAndStabilizeExpression,\n  shouldNotifyChangeForExpression,\n  updateNodeInExpression,\n} from \"@plane/utils\";\nimport type { IFilterConfigManager } from \"./config-manager\";\nimport { FilterConfigManager } from \"./config-manager\";\nimport type { IFilterInstanceHelper } from \"./filter-helpers\";\nimport { FilterInstanceHelper } from \"./filter-helpers\";\n\n/**\n * Interface for a filter instance.\n * Provides methods to manage the filter expression and notify changes.\n * - id: The id of the filter instance\n * - expression: The filter expression\n * - adapter: The filter adapter\n * - configManager: The filter config manager\n * - onExpressionChange: The callback to notify when the expression changes\n * - hasActiveFilters: Whether the filter instance has any active filters\n * - allConditions: All conditions in the filter expression\n * - allConditionsForDisplay: All conditions in the filter expression\n * - addCondition: Adds a condition to the filter expression\n * - updateConditionOperator: Updates the operator of a condition in the filter expression\n * - updateConditionValue: Updates the value of a condition in the filter expression\n * - removeCondition: Removes a condition from the filter expression\n * - clearFilters: Clears the filter expression\n * @template P - The filter property type extending TFilterProperty\n * @template E - The external filter type extending TExternalFilter\n */\nexport interface IFilterInstance<P extends TFilterProperty, E extends TExternalFilter> {\n  // observables\n  id: string;\n  initialFilterExpression: TFilterExpression<P> | null;\n  expression: TFilterExpression<P> | null;\n  adapter: IFilterAdapter<P, E>;\n  configManager: IFilterConfigManager<P>;\n  onExpressionChange?: (expression: E) => void;\n  // computed\n  hasActiveFilters: boolean;\n  hasChanges: boolean;\n  isVisible: boolean;\n  allConditions: TFilterConditionNode<P, TFilterValue>[];\n  allConditionsForDisplay: TFilterConditionNodeForDisplay<P, TFilterValue>[];\n  // computed option helpers\n  clearFilterOptions: TClearFilterOptions | undefined;\n  saveViewOptions: TSaveViewOptions<E> | undefined;\n  updateViewOptions: TUpdateViewOptions<E> | undefined;\n  // computed permissions\n  canClearFilters: boolean;\n  canSaveView: boolean;\n  canUpdateView: boolean;\n  // visibility\n  toggleVisibility: (isVisible?: boolean) => void;\n  // filter expression actions\n  resetExpression: (externalExpression: E, shouldResetInitialExpression?: boolean) => void;\n  // filter condition\n  findConditionsByPropertyAndOperator: (\n    property: P,\n    operator: TAllAvailableOperatorsForDisplay\n  ) => TFilterConditionNodeForDisplay<P, TFilterValue>[];\n  findFirstConditionByPropertyAndOperator: (\n    property: P,\n    operator: TAllAvailableOperatorsForDisplay\n  ) => TFilterConditionNodeForDisplay<P, TFilterValue> | undefined;\n  addCondition: <V extends TFilterValue>(\n    groupOperator: TLogicalOperator,\n    condition: TFilterConditionPayload<P, V>,\n    isNegation: boolean\n  ) => void;\n  updateConditionProperty: (\n    conditionId: string,\n    property: P,\n    operator: TSupportedOperators,\n    isNegation: boolean\n  ) => void;\n  updateConditionOperator: (conditionId: string, operator: TSupportedOperators, isNegation: boolean) => void;\n  updateConditionValue: <V extends TFilterValue>(conditionId: string, value: SingleOrArray<V>) => void;\n  removeCondition: (conditionId: string) => void;\n  // config actions\n  clearFilters: () => Promise<void>;\n  saveView: () => Promise<void>;\n  updateView: () => Promise<void>;\n  // expression options actions\n  updateExpressionOptions: (newOptions: Partial<TExpressionOptions<E>>) => void;\n}\n\ntype TFilterParams<P extends TFilterProperty, E extends TExternalFilter> = {\n  adapter: IFilterAdapter<P, E>;\n  options?: Partial<TFilterOptions<E>>;\n  initialExpression?: E;\n  onExpressionChange?: (expression: E) => void;\n};\n\nexport class FilterInstance<P extends TFilterProperty, E extends TExternalFilter> implements IFilterInstance<P, E> {\n  // observables\n  id: string;\n  initialFilterExpression: TFilterExpression<P> | null;\n  expression: TFilterExpression<P> | null;\n  expressionOptions: TExpressionOptions<E>;\n  adapter: IFilterAdapter<P, E>;\n  configManager: IFilterConfigManager<P>;\n  onExpressionChange?: (expression: E) => void;\n\n  // helper instance\n  private helper: IFilterInstanceHelper<P, E>;\n\n  constructor(params: TFilterParams<P, E>) {\n    this.id = uuidv4();\n    this.adapter = params.adapter;\n    this.helper = new FilterInstanceHelper<P, E>(this, {\n      adapter: this.adapter,\n    });\n    this.configManager = new FilterConfigManager<P, E>(this, {\n      options: params.options?.config,\n    });\n    // initialize expression\n    const initialExpression = this.helper.initializeExpression(params.initialExpression);\n    this.initialFilterExpression = cloneDeep(initialExpression);\n    this.expression = cloneDeep(initialExpression);\n    this.expressionOptions = this.helper.initializeExpressionOptions(params.options?.expression);\n    this.onExpressionChange = params.onExpressionChange;\n    this.helper.setInitialVisibility(params.options?.visibility ?? DEFAULT_FILTER_VISIBILITY_OPTIONS);\n\n    makeObservable(this, {\n      // observables\n      id: observable,\n      initialFilterExpression: observable,\n      expression: observable,\n      expressionOptions: observable.struct,\n      adapter: observable,\n      configManager: observable,\n      // computed\n      hasActiveFilters: computed,\n      hasChanges: computed,\n      isVisible: computed,\n      allConditions: computed,\n      allConditionsForDisplay: computed,\n      // computed option helpers\n      clearFilterOptions: computed,\n      saveViewOptions: computed,\n      updateViewOptions: computed,\n      // computed permissions\n      canClearFilters: computed,\n      canSaveView: computed,\n      canUpdateView: computed,\n      // actions\n      resetExpression: action,\n      findConditionsByPropertyAndOperator: action,\n      findFirstConditionByPropertyAndOperator: action,\n      addCondition: action,\n      updateConditionOperator: action,\n      updateConditionValue: action,\n      removeCondition: action,\n      clearFilters: action,\n      saveView: action,\n      updateView: action,\n      updateExpressionOptions: action,\n    });\n  }\n\n  // ------------ computed ------------\n\n  /**\n   * Checks if the filter instance has any active filters.\n   * @returns True if the filter instance has any active filters, false otherwise.\n   */\n  get hasActiveFilters(): IFilterInstance<P, E>[\"hasActiveFilters\"] {\n    // if the expression is null, return false\n    if (!this.expression) return false;\n    // if there are no conditions, return false\n    if (this.allConditionsForDisplay.length === 0) return false;\n    // if there are conditions, return true if any of them have a valid value\n    return this.allConditionsForDisplay.some((condition) => hasValidValue(condition.value));\n  }\n\n  /**\n   * Checks if the filter instance has any changes with respect to the initial expression.\n   * @returns True if the filter instance has any changes, false otherwise.\n   */\n  get hasChanges(): IFilterInstance<P, E>[\"hasChanges\"] {\n    return !deepCompareFilterExpressions(this.initialFilterExpression, this.expression);\n  }\n\n  /**\n   * Returns the visibility of the filter instance.\n   * @returns The visibility of the filter instance.\n   */\n  get isVisible(): IFilterInstance<P, E>[\"isVisible\"] {\n    return this.helper.isVisible;\n  }\n\n  /**\n   * Returns all conditions from the filter expression.\n   * @returns An array of filter conditions.\n   */\n  get allConditions(): IFilterInstance<P, E>[\"allConditions\"] {\n    if (!this.expression) return [];\n    return extractConditions(this.expression);\n  }\n\n  /**\n   * Returns all conditions in the filter expression for display purposes.\n   * @returns An array of filter conditions for display purposes.\n   */\n  get allConditionsForDisplay(): IFilterInstance<P, E>[\"allConditionsForDisplay\"] {\n    if (!this.expression) return [];\n    return extractConditionsWithDisplayOperators(this.expression);\n  }\n\n  // ------------ computed option helpers ------------\n\n  /**\n   * Returns the clear filter options.\n   * @returns The clear filter options.\n   */\n  get clearFilterOptions(): IFilterInstance<P, E>[\"clearFilterOptions\"] {\n    return this.expressionOptions.clearFilterOptions;\n  }\n\n  /**\n   * Returns the save view options.\n   * @returns The save view options.\n   */\n  get saveViewOptions(): IFilterInstance<P, E>[\"saveViewOptions\"] {\n    return this.expressionOptions.saveViewOptions;\n  }\n\n  /**\n   * Returns the update view options.\n   * @returns The update view options.\n   */\n  get updateViewOptions(): IFilterInstance<P, E>[\"updateViewOptions\"] {\n    return this.expressionOptions.updateViewOptions;\n  }\n\n  // ------------ computed permissions ------------\n\n  /**\n   * Checks if the filter expression can be cleared.\n   * @returns True if the filter expression can be cleared, false otherwise.\n   */\n  get canClearFilters(): IFilterInstance<P, E>[\"canClearFilters\"] {\n    if (!this.expression) return false;\n    if (this.allConditionsForDisplay.length === 0) return false;\n    return this.clearFilterOptions ? !this.clearFilterOptions.isDisabled : true;\n  }\n\n  /**\n   * Checks if the filter expression can be saved as a view.\n   * @returns True if the filter instance can be saved, false otherwise.\n   */\n  get canSaveView(): IFilterInstance<P, E>[\"canSaveView\"] {\n    return this.hasActiveFilters && !!this.saveViewOptions && !this.saveViewOptions.isDisabled;\n  }\n\n  /**\n   * Checks if the filter expression can be updated as a view.\n   * @returns True if the filter expression can be updated, false otherwise.\n   */\n  get canUpdateView(): IFilterInstance<P, E>[\"canUpdateView\"] {\n    return (\n      !!this.updateViewOptions &&\n      (this.hasChanges || !!this.updateViewOptions.hasAdditionalChanges) &&\n      !this.updateViewOptions.isDisabled\n    );\n  }\n\n  // ------------ actions ------------\n\n  /**\n   * Toggles the visibility of the filter instance.\n   * @param isVisible - The visibility to set.\n   */\n  toggleVisibility: IFilterInstance<P, E>[\"toggleVisibility\"] = action((isVisible) => {\n    this.helper.toggleVisibility(isVisible);\n  });\n\n  /**\n   * Resets the filter expression to the initial expression.\n   * @param externalExpression - The external expression to reset to.\n   */\n  resetExpression: IFilterInstance<P, E>[\"resetExpression\"] = action(\n    (externalExpression, shouldResetInitialExpression = true) => {\n      this.expression = this.helper.initializeExpression(externalExpression);\n      if (shouldResetInitialExpression) {\n        this._resetInitialFilterExpression();\n      }\n      this._notifyExpressionChange();\n    }\n  );\n\n  /**\n   * Finds all conditions by property and operator.\n   * @param property - The property to find the conditions by.\n   * @param operator - The operator to find the conditions by.\n   * @returns All the conditions that match the property and operator.\n   */\n  findConditionsByPropertyAndOperator: IFilterInstance<P, E>[\"findConditionsByPropertyAndOperator\"] = action(\n    (property, operator) => {\n      if (!this.expression) return [];\n      return findConditionsByPropertyAndOperator(this.expression, property, operator);\n    }\n  );\n\n  /**\n   * Finds the first condition by property and operator.\n   * @param property - The property to find the condition by.\n   * @param operator - The operator to find the condition by.\n   * @returns The first condition that matches the property and operator.\n   */\n  findFirstConditionByPropertyAndOperator: IFilterInstance<P, E>[\"findFirstConditionByPropertyAndOperator\"] = action(\n    (property, operator) => {\n      if (!this.expression) return undefined;\n      const conditions = findConditionsByPropertyAndOperator(this.expression, property, operator);\n      return conditions[0];\n    }\n  );\n\n  /**\n   * Adds a condition to the filter expression.\n   * @param groupOperator - The logical operator to use for the condition.\n   * @param condition - The condition to add.\n   * @param isNegation - Whether the condition should be negated.\n   */\n  addCondition: IFilterInstance<P, E>[\"addCondition\"] = action((groupOperator, condition, isNegation = false) => {\n    const conditionValue = condition.value;\n\n    this.expression = this.helper.addConditionToExpression(this.expression, groupOperator, condition, isNegation);\n\n    if (hasValidValue(conditionValue)) {\n      this._notifyExpressionChange();\n    }\n  });\n\n  /**\n   * Updates the property of a condition in the filter expression.\n   * @param conditionId - The id of the condition to update.\n   * @param property - The new property for the condition.\n   */\n  updateConditionProperty: IFilterInstance<P, E>[\"updateConditionProperty\"] = action(\n    (conditionId: string, property: P, operator: TSupportedOperators, isNegation: boolean) => {\n      if (!this.expression) return;\n      const conditionBeforeUpdate = cloneDeep(findNodeById(this.expression, conditionId));\n      if (!conditionBeforeUpdate || conditionBeforeUpdate.type !== FILTER_NODE_TYPE.CONDITION) return;\n\n      // Update the condition property\n      const updatedExpression = this.helper.handleConditionPropertyUpdate(\n        this.expression,\n        conditionId,\n        property,\n        operator,\n        isNegation\n      );\n\n      if (updatedExpression) {\n        this.expression = updatedExpression;\n        this._notifyExpressionChange();\n      }\n    }\n  );\n\n  /**\n   * Updates the operator of a condition in the filter expression.\n   * @param conditionId - The id of the condition to update.\n   * @param operator - The new operator for the condition.\n   */\n  updateConditionOperator: IFilterInstance<P, E>[\"updateConditionOperator\"] = action(\n    (conditionId: string, operator: TSupportedOperators, isNegation: boolean) => {\n      if (!this.expression) return;\n      const conditionBeforeUpdate = cloneDeep(findNodeById(this.expression, conditionId));\n      if (!conditionBeforeUpdate || conditionBeforeUpdate.type !== FILTER_NODE_TYPE.CONDITION) return;\n\n      // Get the operator configs for the current and new operators\n      const currentOperatorConfig = this.configManager\n        .getConfigByProperty(conditionBeforeUpdate.property)\n        ?.getOperatorConfig(conditionBeforeUpdate.operator);\n      const newOperatorConfig = this.configManager\n        .getConfigByProperty(conditionBeforeUpdate.property)\n        ?.getOperatorConfig(operator);\n      // Reset the value if the operator config types are different\n      const shouldResetConditionValue = currentOperatorConfig?.type !== newOperatorConfig?.type;\n\n      // Use restructuring logic for operator changes\n      const updatedExpression = this.helper.restructureExpressionForOperatorChange(\n        this.expression,\n        conditionId,\n        operator,\n        isNegation,\n        shouldResetConditionValue\n      );\n\n      if (updatedExpression) {\n        this.expression = updatedExpression;\n      }\n\n      if (hasValidValue(conditionBeforeUpdate.value)) {\n        this._notifyExpressionChange();\n      }\n    }\n  );\n\n  /**\n   * Updates the value of a condition in the filter expression with automatic optimization.\n   * @param conditionId - The id of the condition to update.\n   * @param value - The new value for the condition.\n   */\n  updateConditionValue: IFilterInstance<P, E>[\"updateConditionValue\"] = action(\n    <V extends TFilterValue>(conditionId: string, value: SingleOrArray<V>) => {\n      // If the expression is not valid, return\n      if (!this.expression) return;\n\n      // Get the condition before update\n      const conditionBeforeUpdate = cloneDeep(findNodeById(this.expression, conditionId));\n\n      // If the condition is not valid, return\n      if (!conditionBeforeUpdate || conditionBeforeUpdate.type !== FILTER_NODE_TYPE.CONDITION) return;\n\n      // If the value is not valid, remove the condition\n      if (!hasValidValue(value)) {\n        this.removeCondition(conditionId);\n        return;\n      }\n\n      // If the value is the same as the condition before update, return\n      if (isEqual(conditionBeforeUpdate.value, value)) {\n        return;\n      }\n\n      // Update the condition value\n      updateNodeInExpression(this.expression, conditionId, {\n        value,\n      });\n\n      // Notify the change\n      this._notifyExpressionChange();\n    }\n  );\n\n  /**\n   * Removes a condition from the filter expression.\n   * @param conditionId - The id of the condition to remove.\n   */\n  removeCondition: IFilterInstance<P, E>[\"removeCondition\"] = action((conditionId) => {\n    if (!this.expression) return;\n    const { expression, shouldNotify } = removeNodeFromExpression(this.expression, conditionId);\n    this.expression = expression;\n    if (shouldNotify) {\n      this._notifyExpressionChange();\n    }\n  });\n\n  /**\n   * Clears the filter expression.\n   */\n  clearFilters: IFilterInstance<P, E>[\"clearFilters\"] = action(async () => {\n    if (this.canClearFilters) {\n      const shouldNotify = shouldNotifyChangeForExpression(this.expression);\n      this.expression = null;\n      await this.clearFilterOptions?.onFilterClear();\n      if (shouldNotify) {\n        this._notifyExpressionChange();\n      }\n    } else {\n      console.warn(\"Cannot clear filters: invalid expression or missing options.\");\n    }\n  });\n\n  /**\n   * Saves the filter expression.\n   */\n  saveView: IFilterInstance<P, E>[\"saveView\"] = action(async () => {\n    if (this.canSaveView && this.saveViewOptions) {\n      await this.saveViewOptions.onViewSave(this._getExternalExpression());\n    } else {\n      console.warn(\"Cannot save view: invalid expression or missing options.\");\n    }\n  });\n\n  /**\n   * Updates the filter expression.\n   */\n  updateView: IFilterInstance<P, E>[\"updateView\"] = action(async () => {\n    if (this.canUpdateView && this.updateViewOptions) {\n      await this.updateViewOptions.onViewUpdate(this._getExternalExpression());\n      this._resetInitialFilterExpression();\n    } else {\n      console.warn(\"Cannot update view: invalid expression or missing options.\");\n    }\n  });\n\n  /**\n   * Updates the expression options for the filter instance.\n   * This allows dynamic updates to options like isDisabled properties.\n   */\n  updateExpressionOptions: IFilterInstance<P, E>[\"updateExpressionOptions\"] = action((newOptions) => {\n    this.expressionOptions = {\n      ...this.expressionOptions,\n      ...newOptions,\n    };\n  });\n\n  // ------------ private helpers ------------\n  /**\n   * Resets the initial filter expression to the current expression.\n   */\n  private _resetInitialFilterExpression(): void {\n    this.initialFilterExpression = cloneDeep(this.expression);\n  }\n\n  /**\n   * Returns the external filter representation of the filter instance.\n   * @returns The external filter representation of the filter instance.\n   */\n  private _getExternalExpression = computedFn(() =>\n    this.adapter.toExternal(sanitizeAndStabilizeExpression(toJS(this.expression)))\n  );\n\n  /**\n   * Notifies the parent component of the expression change.\n   */\n  private _notifyExpressionChange(): void {\n    this.onExpressionChange?.(this._getExternalExpression());\n  }\n}\n","// plane imports\nimport { isEmpty } from \"lodash-es\";\nimport type {\n  SingleOrArray,\n  TFilterExpression,\n  TFilterValue,\n  TSupportedOperators,\n  TWorkItemFilterConditionData,\n  TWorkItemFilterConditionKey,\n  TWorkItemFilterExpression,\n  TWorkItemFilterExpressionData,\n  TWorkItemFilterProperty,\n} from \"@plane/types\";\nimport { LOGICAL_OPERATOR, MULTI_VALUE_OPERATORS, WORK_ITEM_FILTER_PROPERTY_KEYS } from \"@plane/types\";\nimport { createConditionNode, createAndGroupNode, isAndGroupNode, isConditionNode } from \"@plane/utils\";\n// local imports\nimport { FilterAdapter } from \"../rich-filters/adapter\";\n\nclass WorkItemFiltersAdapter extends FilterAdapter<TWorkItemFilterProperty, TWorkItemFilterExpression> {\n  /**\n   * Converts external work item filter expression to internal filter tree\n   * @param externalFilter - The external filter expression\n   * @returns Internal filter expression or null\n   */\n  toInternal(externalFilter: TWorkItemFilterExpression): TFilterExpression<TWorkItemFilterProperty> | null {\n    if (!externalFilter || isEmpty(externalFilter)) return null;\n\n    try {\n      return this._convertExpressionToInternal(externalFilter);\n    } catch (error) {\n      console.error(\"Failed to convert external filter to internal:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Recursively converts external expression data to internal filter tree\n   * @param expression - The external expression data\n   * @returns Internal filter expression\n   */\n  private _convertExpressionToInternal(\n    expression: TWorkItemFilterExpressionData\n  ): TFilterExpression<TWorkItemFilterProperty> {\n    if (!expression || isEmpty(expression)) {\n      throw new Error(\"Invalid expression: empty or null data\");\n    }\n\n    // Check if it's a simple condition (has field property)\n    if (this._isWorkItemFilterConditionData(expression)) {\n      const conditionResult = this._extractWorkItemFilterConditionData(expression);\n      if (!conditionResult) {\n        throw new Error(\"Failed to extract condition data\");\n      }\n\n      const [property, operator, value] = conditionResult;\n      return createConditionNode({\n        property,\n        operator,\n        value,\n      });\n    }\n\n    // It's a logical group - check which type\n    const expressionKeys = Object.keys(expression);\n\n    if (LOGICAL_OPERATOR.AND in expression) {\n      const andExpression = expression as { [LOGICAL_OPERATOR.AND]: TWorkItemFilterExpressionData[] };\n      const andConditions = andExpression[LOGICAL_OPERATOR.AND];\n\n      if (!Array.isArray(andConditions) || andConditions.length === 0) {\n        throw new Error(\"AND group must contain at least one condition\");\n      }\n\n      const convertedConditions = andConditions.map((item) => this._convertExpressionToInternal(item));\n      return createAndGroupNode(convertedConditions);\n    }\n\n    throw new Error(`Invalid expression: unknown structure with keys [${expressionKeys.join(\", \")}]`);\n  }\n\n  /**\n   * Converts internal filter expression to external format\n   * @param internalFilter - The internal filter expression\n   * @returns External filter expression\n   */\n  toExternal(internalFilter: TFilterExpression<TWorkItemFilterProperty>): TWorkItemFilterExpression {\n    if (!internalFilter) {\n      return {};\n    }\n\n    try {\n      return this._convertExpressionToExternal(internalFilter);\n    } catch (error) {\n      console.error(\"Failed to convert internal filter to external:\", error);\n      return {};\n    }\n  }\n\n  /**\n   * Recursively converts internal expression to external format\n   * @param expression - The internal filter expression\n   * @returns External expression data\n   */\n  private _convertExpressionToExternal(\n    expression: TFilterExpression<TWorkItemFilterProperty>\n  ): TWorkItemFilterExpressionData {\n    if (isConditionNode(expression)) {\n      return this._createWorkItemFilterConditionData(expression.property, expression.operator, expression.value);\n    }\n\n    // It's a group node\n\n    if (isAndGroupNode(expression)) {\n      return {\n        [LOGICAL_OPERATOR.AND]: expression.children.map((child) => this._convertExpressionToExternal(child)),\n      } as TWorkItemFilterExpressionData;\n    }\n\n    throw new Error(`Unknown group node type for expression`);\n  }\n\n  /**\n   * Type guard to check if data is of type TWorkItemFilterConditionData\n   * @param data - The data to check\n   * @returns True if data is TWorkItemFilterConditionData, false otherwise\n   */\n  private _isWorkItemFilterConditionData = (data: unknown): data is TWorkItemFilterConditionData => {\n    if (!data || typeof data !== \"object\" || isEmpty(data)) return false;\n\n    const keys = Object.keys(data);\n    if (keys.length === 0) return false;\n\n    // Check if any key contains logical operators (would indicate it's a group)\n    const hasLogicalOperators = keys.some((key) => key === LOGICAL_OPERATOR.AND);\n    if (hasLogicalOperators) return false;\n\n    // All keys must match the work item filter condition key pattern\n    return keys.every((key) => this._isValidWorkItemFilterConditionKey(key));\n  };\n\n  /**\n   * Validates if a key is a valid work item filter condition key\n   * @param key - The key to validate\n   * @returns True if the key is valid\n   */\n  private _isValidWorkItemFilterConditionKey = (key: string): key is TWorkItemFilterConditionKey => {\n    if (typeof key !== \"string\" || key.length === 0) return false;\n\n    // Find the last occurrence of '__' to separate property from operator\n    const lastDoubleUnderscoreIndex = key.lastIndexOf(\"__\");\n    if (\n      lastDoubleUnderscoreIndex === -1 ||\n      lastDoubleUnderscoreIndex === 0 ||\n      lastDoubleUnderscoreIndex === key.length - 2\n    ) {\n      return false;\n    }\n\n    const property = key.substring(0, lastDoubleUnderscoreIndex);\n    const operator = key.substring(lastDoubleUnderscoreIndex + 2);\n\n    // Validate property is in allowed list\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (!WORK_ITEM_FILTER_PROPERTY_KEYS.includes(property as any) && !property.startsWith(\"customproperty_\")) {\n      return false;\n    }\n\n    // Validate operator is not empty\n    return operator.length > 0;\n  };\n\n  /**\n   * Extracts property, operator and value from work item filter condition data\n   * @param data - The condition data\n   * @returns Tuple of property, operator and value, or null if invalid\n   */\n  private _extractWorkItemFilterConditionData = (\n    data: TWorkItemFilterConditionData\n  ): [TWorkItemFilterProperty, TSupportedOperators, SingleOrArray<TFilterValue>] | null => {\n    const keys = Object.keys(data);\n    if (keys.length !== 1) {\n      console.error(\"Work item filter condition data must have exactly one key\");\n      return null;\n    }\n\n    const key = keys[0];\n    if (!this._isValidWorkItemFilterConditionKey(key)) {\n      console.error(`Invalid work item filter condition key: ${key}`);\n      return null;\n    }\n\n    // Find the last occurrence of '__' to separate property from operator\n    const lastDoubleUnderscoreIndex = key.lastIndexOf(\"__\");\n    const property = key.substring(0, lastDoubleUnderscoreIndex);\n    const operator = key.substring(lastDoubleUnderscoreIndex + 2) as TSupportedOperators;\n\n    const rawValue = data[key];\n\n    // Parse comma-separated values\n    const parsedValue = MULTI_VALUE_OPERATORS.includes(operator) ? this._parseFilterValue(rawValue) : rawValue;\n\n    return [property as TWorkItemFilterProperty, operator, parsedValue];\n  };\n\n  /**\n   * Parses filter value from string format\n   * @param value - The string value to parse\n   * @returns Parsed value as string or array of strings\n   */\n  private _parseFilterValue = (value: TFilterValue): SingleOrArray<TFilterValue> => {\n    if (!value) return value;\n\n    if (typeof value !== \"string\") return value;\n\n    // Handle empty string\n    if (value === \"\") return value;\n\n    // Split by comma if contains comma, otherwise return as single value\n    if (value.includes(\",\")) {\n      // Split and trim each value, filter out empty strings\n      const splitValues = value\n        .split(\",\")\n        .map((v) => v.trim())\n        .filter((v) => v.length > 0);\n\n      // Return single value if only one non-empty value after split\n      return splitValues.length === 1 ? splitValues[0] : splitValues;\n    }\n\n    return value;\n  };\n\n  /**\n   * Creates TWorkItemFilterConditionData from property, operator and value\n   * @param property - The filter property key\n   * @param operator - The filter operator\n   * @param value - The filter value\n   * @returns The condition data object\n   */\n  private _createWorkItemFilterConditionData = (\n    property: TWorkItemFilterProperty,\n    operator: TSupportedOperators,\n    value: SingleOrArray<TFilterValue>\n  ): TWorkItemFilterConditionData => {\n    const conditionKey = `${property}__${operator}`;\n\n    // Convert value to string format\n    const stringValue = Array.isArray(value) ? value.join(\",\") : value;\n\n    return {\n      [conditionKey]: stringValue,\n    } as TWorkItemFilterConditionData;\n  };\n}\n\nexport const workItemFiltersAdapter = new WorkItemFiltersAdapter();\n","// plane imports\nimport type { TBuildFilterExpressionParams, TExternalFilter, TFilterProperty, TFilterValue } from \"@plane/types\";\nimport { LOGICAL_OPERATOR } from \"@plane/types\";\nimport { getOperatorForPayload } from \"@plane/utils\";\n// local imports\nimport { FilterInstance } from \"../store/rich-filters/filter\";\n\n/**\n * Builds a temporary filter expression from conditions.\n * @param params.conditions - The conditions for building the filter expression.\n * @param params.adapter - The adapter for building the filter expression.\n * @returns The temporary filter expression.\n */\nexport const buildTempFilterExpressionFromConditions = <\n  P extends TFilterProperty,\n  V extends TFilterValue,\n  E extends TExternalFilter,\n>(\n  params: TBuildFilterExpressionParams<P, V, E>\n): E | undefined => {\n  const { conditions, adapter } = params;\n  let tempExpression: E | undefined = undefined;\n  const tempFilterInstance = new FilterInstance<P, E>({\n    adapter,\n    onExpressionChange: (expression) => {\n      tempExpression = expression;\n    },\n  });\n  for (const condition of conditions) {\n    const { operator, isNegation } = getOperatorForPayload(condition.operator);\n    tempFilterInstance.addCondition(\n      LOGICAL_OPERATOR.AND,\n      {\n        property: condition.property,\n        operator,\n        value: condition.value,\n      },\n      isNegation\n    );\n  }\n  return tempExpression;\n};\n","// plane imports\nimport type {\n  TBuildFilterExpressionParams,\n  TFilterConditionForBuild,\n  TFilterValue,\n  TWorkItemFilterExpression,\n  TWorkItemFilterProperty,\n} from \"@plane/types\";\n// local imports\nimport { workItemFiltersAdapter } from \"../store/work-item-filters/adapter\";\nimport { buildTempFilterExpressionFromConditions } from \"./rich-filter.helper\";\n\nexport type TWorkItemFilterCondition = TFilterConditionForBuild<TWorkItemFilterProperty, TFilterValue>;\n\n/**\n * Builds a work item filter expression from conditions.\n * @param params.conditions - The conditions for building the filter expression.\n * @returns The work item filter expression.\n */\nexport const buildWorkItemFilterExpressionFromConditions = (\n  params: Omit<\n    TBuildFilterExpressionParams<TWorkItemFilterProperty, TFilterValue, TWorkItemFilterExpression>,\n    \"adapter\"\n  >\n): TWorkItemFilterExpression | undefined => {\n  const workItemFilterExpression = buildTempFilterExpressionFromConditions({\n    ...params,\n    adapter: workItemFiltersAdapter,\n  });\n  if (!workItemFilterExpression) console.error(\"Failed to build work item filter expression from conditions\");\n  return workItemFilterExpression;\n};\n","import { action, makeObservable, observable } from \"mobx\";\nimport { computedFn } from \"mobx-utils\";\n// plane imports\nimport type { TExpressionOptions } from \"@plane/constants\";\nimport type { EIssuesStoreType, TWorkItemFilterExpression, TWorkItemFilterProperty } from \"@plane/types\";\nimport { LOGICAL_OPERATOR } from \"@plane/types\";\nimport { getOperatorForPayload } from \"@plane/utils\";\n// local imports\nimport type { TWorkItemFilterCondition } from \"../../utils\";\nimport { buildWorkItemFilterExpressionFromConditions } from \"../../utils\";\nimport { FilterInstance } from \"../rich-filters/filter\";\nimport { workItemFiltersAdapter } from \"./adapter\";\nimport type { IWorkItemFilterInstance, TWorkItemFilterKey } from \"./shared\";\n\ntype TGetOrCreateFilterParams = {\n  showOnMount?: boolean;\n  entityId: string;\n  entityType: EIssuesStoreType;\n  expressionOptions?: TExpressionOptions<TWorkItemFilterExpression>;\n  initialExpression?: TWorkItemFilterExpression;\n  onExpressionChange?: (expression: TWorkItemFilterExpression) => void;\n};\n\nexport interface IWorkItemFilterStore {\n  filters: Map<TWorkItemFilterKey, IWorkItemFilterInstance>; // key is the entity id (project, cycle, workspace, teamspace, etc)\n  getFilter: (entityType: EIssuesStoreType, entityId: string) => IWorkItemFilterInstance | undefined;\n  getOrCreateFilter: (params: TGetOrCreateFilterParams) => IWorkItemFilterInstance;\n  resetExpression: (entityType: EIssuesStoreType, entityId: string, expression: TWorkItemFilterExpression) => void;\n  updateFilterExpressionFromConditions: (\n    entityType: EIssuesStoreType,\n    entityId: string,\n    conditions: TWorkItemFilterCondition[],\n    fallbackFn: (expression: TWorkItemFilterExpression) => Promise<void>\n  ) => Promise<void>;\n  updateFilterValueFromSidebar: (\n    entityType: EIssuesStoreType,\n    entityId: string,\n    condition: TWorkItemFilterCondition\n  ) => void;\n  deleteFilter: (entityType: EIssuesStoreType, entityId: string) => void;\n}\n\nexport class WorkItemFilterStore implements IWorkItemFilterStore {\n  // observable\n  filters: IWorkItemFilterStore[\"filters\"];\n\n  constructor() {\n    this.filters = new Map<TWorkItemFilterKey, IWorkItemFilterInstance>();\n    makeObservable(this, {\n      filters: observable,\n      getOrCreateFilter: action,\n      resetExpression: action,\n      updateFilterExpressionFromConditions: action,\n      deleteFilter: action,\n    });\n  }\n\n  // ------------ computed functions ------------\n\n  /**\n   * Returns a filter instance.\n   * @param entityType - The entity type.\n   * @param entityId - The entity id.\n   * @returns The filter instance.\n   */\n  getFilter: IWorkItemFilterStore[\"getFilter\"] = computedFn((entityType, entityId) =>\n    this.filters.get(this._getFilterKey(entityType, entityId))\n  );\n\n  // ------------ actions ------------\n\n  /**\n   * Gets or creates a new filter instance.\n   * If the instance already exists, updates its expression options to ensure they're current.\n   */\n  getOrCreateFilter: IWorkItemFilterStore[\"getOrCreateFilter\"] = action((params) => {\n    const existingFilter = this.getFilter(params.entityType, params.entityId);\n    if (existingFilter) {\n      // Update expression options on existing filter to ensure they're current\n      if (params.expressionOptions) {\n        existingFilter.updateExpressionOptions(params.expressionOptions);\n      }\n      // Update callback if provided\n      if (params.onExpressionChange) {\n        existingFilter.onExpressionChange = params.onExpressionChange;\n      }\n      // Update visibility if provided\n      if (params.showOnMount !== undefined) {\n        existingFilter.toggleVisibility(params.showOnMount);\n      }\n      return existingFilter;\n    }\n\n    // create new filter instance\n    const newFilter = this._initializeFilterInstance(params);\n    const filterKey = this._getFilterKey(params.entityType, params.entityId);\n    this.filters.set(filterKey, newFilter);\n\n    return newFilter;\n  });\n\n  /**\n   * Resets the initial expression for a filter instance.\n   * @param entityType - The entity type.\n   * @param entityId - The entity id.\n   * @param expression - The expression to update.\n   */\n  resetExpression: IWorkItemFilterStore[\"resetExpression\"] = action((entityType, entityId, expression) => {\n    const filter = this.getFilter(entityType, entityId);\n    if (filter) {\n      filter.resetExpression(expression);\n    }\n  });\n\n  /**\n   * Updates the filter expression from conditions.\n   * @param entityType - The entity type.\n   * @param entityId - The entity id.\n   * @param conditions - The conditions to update.\n   * @param fallbackFn - The fallback function to update the expression if the filter instance does not exist.\n   */\n  updateFilterExpressionFromConditions: IWorkItemFilterStore[\"updateFilterExpressionFromConditions\"] = action(\n    async (entityType, entityId, conditions, fallbackFn) => {\n      const filter = this.getFilter(entityType, entityId);\n      const newFilterExpression = buildWorkItemFilterExpressionFromConditions({\n        conditions,\n      });\n      if (!newFilterExpression) return;\n\n      // Update the filter expression using the filter instance if it exists, otherwise use the fallback function\n      if (filter) {\n        filter.resetExpression(newFilterExpression, false);\n      } else {\n        await fallbackFn(newFilterExpression);\n      }\n    }\n  );\n\n  /**\n   * Handles sidebar filter updates by adding new conditions or updating existing ones.\n   * This method processes filter conditions from the sidebar UI and applies them to the\n   * appropriate filter instance, handling both positive and negative operators correctly.\n   *\n   * @param entityType - The entity type (e.g., project, cycle, module)\n   * @param entityId - The unique identifier for the entity\n   * @param condition - The filter condition containing property, operator, and value\n   */\n  updateFilterValueFromSidebar: IWorkItemFilterStore[\"updateFilterValueFromSidebar\"] = action(\n    (entityType, entityId, condition) => {\n      // Retrieve the filter instance for the specified entity\n      const filter = this.getFilter(entityType, entityId);\n\n      // Early return if filter instance doesn't exist\n      if (!filter) {\n        console.warn(\n          `Cannot handle sidebar filters update: filter instance not found for entity type \"${entityType}\" with ID \"${entityId}\"`\n        );\n        return;\n      }\n\n      // Check for existing conditions with the same property and operator\n      const conditionNode = filter.findFirstConditionByPropertyAndOperator(condition.property, condition.operator);\n\n      // No existing condition found - add new condition with AND logic\n      if (!conditionNode) {\n        const { operator, isNegation } = getOperatorForPayload(condition.operator);\n\n        // Create the condition payload with normalized operator\n        const conditionPayload = {\n          property: condition.property,\n          operator,\n          value: condition.value,\n        };\n\n        filter.addCondition(LOGICAL_OPERATOR.AND, conditionPayload, isNegation);\n        return;\n      }\n\n      // Update existing condition (assuming single condition per property-operator pair)\n      filter.updateConditionValue(conditionNode.id, condition.value);\n    }\n  );\n\n  /**\n   * Deletes a filter instance.\n   * @param entityType - The entity type.\n   * @param entityId - The entity id.\n   */\n  deleteFilter: IWorkItemFilterStore[\"deleteFilter\"] = action((entityType, entityId) => {\n    this.filters.delete(this._getFilterKey(entityType, entityId));\n  });\n\n  // ------------ private helpers ------------\n\n  /**\n   * Returns a filter key.\n   * @param entityType - The entity type.\n   * @param entityId - The entity id.s\n   * @returns The filter key.\n   */\n  _getFilterKey = (entityType: EIssuesStoreType, entityId: string): TWorkItemFilterKey => `${entityType}-${entityId}`;\n\n  /**\n   * Initializes a filter instance.\n   * @param params - The parameters for the filter instance.\n   * @returns The filter instance.\n   */\n  _initializeFilterInstance = (params: TGetOrCreateFilterParams) =>\n    new FilterInstance<TWorkItemFilterProperty, TWorkItemFilterExpression>({\n      adapter: workItemFiltersAdapter,\n      initialExpression: params.initialExpression,\n      onExpressionChange: params.onExpressionChange,\n      options: {\n        expression: params.expressionOptions,\n        visibility: params.showOnMount\n          ? { autoSetVisibility: false, isVisibleOnMount: true }\n          : { autoSetVisibility: true },\n      },\n    });\n}\n"],"mappings":"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"}